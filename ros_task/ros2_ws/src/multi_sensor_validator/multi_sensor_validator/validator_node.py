import random
from multi_sensor_validator.i_publisher import IPublisher
from multi_sensor_validator.utility import Utility
from rclpy.node import Node
from std_msgs.msg import String, Int32
from sensor_msgs.msg import Range
from sensor_validator_interfaces.msg import SensorProperties


class ValidatorNode(Node, IPublisher):
    """Node that simulates an validator by publishing random range values."""

    def __init__(self, sesnors_topics=["ultrasonic_range", "infrared_range"], timer_period=2, queue_size=10):
        super().__init__('validator_node')
        self.get_logger().info('Validator Node has been started.')

        self.sensors_readings = dict()
        self.topics_subscriptions = dict()
        for topic in sesnors_topics:
            self.topics_subscriptions[topic] = self.create_subscription(
                Int32, topic, lambda msg, t=topic: self.topic_callback(
                    t, msg), queue_size
            )

        # self._publisher = self.create_publisher(
        #     String, "validation_result", queue_size
        # )
        self._publisher = self.create_publisher(
            SensorProperties, "sensor_properties", queue_size
        )
        # Timer
        self._timer = self.create_timer(
            timer_period+0.5, self.publish_msg)

    def topic_callback(self, topic, msg):
        # self.get_logger().info(f"Recieved: {msg.data} from {topic}")
        self.sensors_readings[topic] = msg.data

    def validate_measurements(self):
        """Validate the data from both sensors."""
        validation_result = False
        previous_reading = None
        for _, reading in self.sensors_readings.items():
            if previous_reading is None:
                previous_reading = reading
            else:
                if abs(previous_reading - reading) <= 20:
                    validation_result = True
                else:
                    validation_result = False
                    break
                previous_reading = reading

        return validation_result

    def publish_msg(self):
        """Publish a message with data generated by the subclass."""
        validation_result = self.validate_measurements()
        # msg = String()
        msg = SensorProperties()
        validation_msg = "Sensor readings consistent" if validation_result else "Sensor readings inconsistent"
        # msg.data = ""
        msg.quality = random.randint(0, 100)
        ranges = dict()
        for topic in self.topics_subscriptions.keys():
            ranges[topic] = Range()
            ranges[topic].header.stamp = self.get_clock().now().to_msg()
            ranges[topic].header.frame_id = topic.split("_")[0]
            ranges[topic].radiation_type = Range.ULTRASOUND if "ultrasonic" in topic else Range.INFRARED
            ranges[topic].min_range = 2.0
            ranges[topic].max_range = 200.0 if "ultrasonic" in topic else 150.0
            ranges[topic].range = float(self.sensors_readings.get(topic, random.uniform(
                50.0, 150.0) if "ultrasonic" in topic else random.uniform(30.0, 120.0)))

        # Add to message
        msg.sensor_values = [ranges[topic]
                             for topic in self.topics_subscriptions.keys()]

        # for topic, reading in self.sensors_readings.items():
        #     data = f"{topic.split("_")[0].capitalize()}: {reading} cm"
        #     msg.data = data if msg.data == "" else f"{msg.data}, {data}"

        # msg.data = f"{msg.data} â†’ {validation_msg}"
        self._publisher.publish(msg)
        # self.get_logger().info(f"Publishing: {msg.data}")


def main(args=None):
    Utility.run_node(args=args, node_factory=lambda: ValidatorNode(sesnors_topics=[
                     "ultrasonic_range", "infrared_range"], timer_period=Utility.timer_period, queue_size=Utility.queue_size))


if __name__ == '__main__':
    main()
